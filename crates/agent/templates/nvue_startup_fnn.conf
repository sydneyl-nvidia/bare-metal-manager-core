{{- $nvueConfig := . -}}
- header:
    model: VX
    nvue-api-version: nvue_v1
    rev-id: 1.0
    version: Cumulus Linux 5.6.0
{{- $tenant := .Tenant }}
- set:
{{- if .IncludeBridge }} {{/* Only if an L2 segment exists should bridges be configured */}}
    bridge:
      domain:
        br_default:
          vlan:
  {{- range $portConfig := $tenant.PortConfigs }}
    {{- if $portConfig.IsL2Segment }}
            '{{ $portConfig.VlanID }}':
              vni:
                '{{ $portConfig.L2VNI }}': {} {{/* Always configuring an L2VNI, even if not necessary. Less conditions in the template */}}
    {{- end }}
  {{- end }}
{{- end }}
    evpn:
      enable: on
    interface:
      lo:
        ip:
          address:
            {{ .LoopbackIP }}/32: {}
        type: loopback
{{- range $portConfig := $tenant.PortConfigs }}
  {{- if $portConfig.IsPhy }}
      pf0dpu1_if:
        ip:
          address:
            169.254.169.253/30: {}
          vrf: {{ $portConfig.VrfName }}
  {{- end }}          
{{- end }}          
{{- if .IsStorageClient }} {{/* New variable to be created to define if a node is a storage client and the interface should be created */}}
      pf0dpu3_if:
        ip:
          address:
            {{ $.StorageDpuIP }}: {}
        vrf: storage
{{- end }}
{{- if $nvueConfig.HasInternalBridgeRouting }}
      {{ $nvueConfig.VfInterceptBridgeSf }}_if:
        ip:
          address:
            {{ $nvueConfig.VfInterceptHbnRepresentorIp }}/{{ $nvueConfig.InterceptBridgePrefixLen }}: {}
{{- end }}
{{- range .Uplinks}}
      {{ . }}:
        type: swp
{{- end }}
{{- range $portConfig := $tenant.PortConfigs }}
      {{ $portConfig.InterfaceName }}:
        type: swp
        acl: {{/* Removing condition of use-case. ACL should always be configured. The condition should be for the ACL content and not the existance */}}
        {{- if $nvueConfig.HasDenyPrefixes }}
          p0000_deny_prefixes_ipv4:
            inbound: {}
        {{- end }}
        {{- if $nvueConfig.HasIpv4EgressSecurityPolicyOverrideRules }}
          p0004_security_policy_override_ipv4_host_egress:          
            inbound: {}
        {{- end }}
        {{- if $nvueConfig.HasIpv6EgressSecurityPolicyOverrideRules }}
          p0004_security_policy_override_ipv6_host_egress:
            inbound: {}
        {{- end }}
        {{- if $nvueConfig.HasIpv4IngressSecurityPolicyOverrideRules }}
          p0004_security_policy_override_ipv4_host_ingress:
            outbound: {}
        {{- end }}
        {{- if $nvueConfig.HasIpv6IngressSecurityPolicyOverrideRules }}
          p0004_security_policy_override_ipv6_host_ingress:
            outbound: {}
        {{- end }}
        {{- if $portConfig.HasNetworkSecurityGroup }}
          p0005_{{ $portConfig.NetworkSecurityGroupIndex }}_security_group_ipv4_host_egress: 
            inbound: {}
          p0005_{{ $portConfig.NetworkSecurityGroupIndex }}_security_group_ipv6_host_egress:
            inbound: {}
          p0005_{{ $portConfig.NetworkSecurityGroupIndex }}_security_group_ipv4_host_ingress: 
            outbound: {}
          p0005_{{ $portConfig.NetworkSecurityGroupIndex }}_security_group_ipv6_host_ingress: 
            outbound: {}
        {{- end }}
        {{- if $portConfig.HasVpcPeerPrefixes }}
          p0009_{{ $portConfig.VrfName }}_peer_egress_from_host:
            inbound: {}
          p0009_{{ $portConfig.VrfName }}_peer_ingress_to_host:
            outbound: {}
        {{- end }}
        {{- if and ($nvueConfig.UseVpcIsolation) ($nvueConfig.HasSiteFabricPrefixes) }}
          p0010_{{ $portConfig.VrfName }}_isolation_ipv4:
            inbound: {}
        {{- end }}
   {{- if $portConfig.IsL2Segment }}
          dhcp_flood_prevention:
            inbound: {}
   {{- end }}
   {{- if not $portConfig.IsL2Segment }} {{/* If not L2, IP will be directly configured on the interface */}}
        ip:
          address:
          {{- range $portConfig.IPs }}
            {{ . }}: {} {{/* In case of FNN L3, this is the first IP in the /31 in the prefix */}}
          {{- end }}
          vrf: {{ $portConfig.VrfName }} {{/* The name of the VRF (VPC) this interface should be in */}}
     {{- else }} {{/* If the segment is L2, the interface should be configured in the bridge */}}
        bridge:
          domain:
            br_default:
              access: {{ $portConfig.VlanID }}
   {{- end }}
  {{- if $portConfig.IsL2Segment }} {{/* If the segment is L2, an SVI is needed */}}
      vlan{{ $portConfig.VlanID }}:
        type: svi
        vlan: {{ $portConfig.VlanID }}
        ip:
          address:
            {{ $portConfig.SviIP }}: {} {{/* The SviIP is a _different_ ip from the same subnet than the gateway. Typically the second IP in the subnet */}}
          vrf: {{ $portConfig.VrfName }} {{/* The name of the VRF (VPC) this interface should be in */}}
          vrr:
            address:
            {{- range $portConfig.IPs }}
              {{ . }}: {} {{/* In case of FNN l2, the first IP from the subnet */}}
            {{- end }}
            enable: on
            mac-address: {{ $portConfig.SviMAC }} {{/* A shared MAC address for all vlan interfaces in the same VNI (VPC) */}}
            state:
              up: {}
  {{- end }}
{{- end }}
    nve:
      vxlan:
        arp-nd-suppress: on
        enable: on
        source:
          address: {{ $nvueConfig.LoopbackIP }} {{/* Unique DPU Loopback used as VTEP */}}
    router:
      bgp:
        autonomous-system: {{ $nvueConfig.ASN }} {{/* Unique DPU ASN */}}
        enable: on
        router-id: {{ $nvueConfig.LoopbackIP }}
      vrr:
        enable: on
      policy:
        community-list:
          BYOIP_LEAK_COMMUNITY_LIST:
            rule:
              '10':
                action: permit
                community:
                  65100:01: {}
        as-path-list:
          DPU_TO_EVPN_AS_PATH_DROP_LIST:
            rule:
              '10':
                action: permit{{/* This means 'match', not 'allow' */}}
                aspath-exp: "^.+$"{{/* Match on anything that we did not originate */}}
        prefix-list:
          ALLOW_TO_UNDERLAY_PREFIX_LIST:
            rule:
              '65000':
                action: permit
                match:
                  {{ $nvueConfig.LoopbackIP }}/32: {}
              {{- if $nvueConfig.HasSecondaryOverlayVTEP }}
              '65001':
                action: permit
                match:
                  {{ $nvueConfig.SecondaryOverlayVtepIP }}/32: {}
              {{- end }}
          DPU_FROM_INSTANCE_PREFIX_LIST:
            rule:
            {{- range $nvueConfig.AnycastSitePrefixes }}
              '{{ .Index }}':
                action: permit
                match:
                  {{ .Prefix }}:
                    min-prefix-len: 32
            {{- end }}
              '65535':
                action: deny
                match:
                  any: {}
          DPU_FROM_TRAFFIC_INTERCEPT_PEER_PREFIX_LIST:
            rule:
                  {{- range $nvueConfig.TrafficInterceptPublicPrefixes }}
              '{{ .Index }}':
                action: permit
                match:
                  {{ .Prefix }}: {}
                  {{- end }}
              '65535':
                action: deny
                match:
                  any: {}
          DPU_TO_EVPN_DROP_PREFIX_LIST:
            rule:
              '10':
                action: permit{{/* This means 'match', not 'allow' */}}
                match:
                {{- range $vpc := $tenant.Vpcs }}
                  {{ $vpc.VrfLoopback }}/32: {}{{/* Still not clear we really even need a loopback on the VRF for our use-case, and we allow duplication between sites, so keep the type-5 route for it out of the overlay. */}}
                {{- end }}
        route-map:
          dpu_to_evpn:
            rule:
              '10':
                action:
                  deny: {}
                match:
                  type: ipv4
                  evpn-route-type: ip-prefix
                  ip-prefix-list: DPU_TO_EVPN_DROP_PREFIX_LIST
              '11':
                action:
                  permit: {}
                match:
                  tag: 65100{{/* Allow prefixes learned from the host */}}
              '12':
                action:
                  permit: {}
                match:
                  tag: 65101{{/* Allow prefixes learned from the host */}}
              '13':
                action:
                  deny: {}
                match:
                  as-path-list: DPU_TO_EVPN_AS_PATH_DROP_LIST
              '65535':
                action:
                  permit: {}{{/* We originally did no filtering here.  An attempt to use an "allow" prefix-list and default deny route-map stripped more than expected.  It seems like a bug that we need to look into. For now, we just drop the prefixes that we wanted dropped. */}}
          leak_to_underlay:
            rule:
              '65533':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: ALLOW_TO_UNDERLAY_PREFIX_LIST
                set:
                  community:
                    none: {}{{/* We strip here just in case something accidentally slipped through */}}
                  large-community:
                    none: {}
              '65534':
                action:
                  permit: {}
                match:
                  tag: 65100
                set:
                  community:
                    none: {}
                  large-community:
                    none: {}
              '65535':
                action:
                  deny: {}
          dpu_from_traffic_intercept_gw_peer:
            rule:
              '10':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: DPU_FROM_TRAFFIC_INTERCEPT_PEER_PREFIX_LIST
                  community-list: BYOIP_LEAK_COMMUNITY_LIST
                set:
                  tag: 65100{{/* tag it so we can match on the tag and use it for leaking later */}}
                  community:
                    none: {}{{/* Strip any communities the peer might have attached. */}}
                  large-community:
                    none: {}
              '11':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: DPU_FROM_TRAFFIC_INTERCEPT_PEER_PREFIX_LIST
                set:
                  tag: 65101{{/* tag it so we can match on the tag and use it for leaking later */}}
                  community:
                    none: {}{{/* Strip any communities the peer might have attached. */}}
                  large-community:
                    none: {}
              '65535':
                action:
                  deny: {}
          dpu_from_instance:
            rule:
              '10':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: DPU_FROM_INSTANCE_PREFIX_LIST
                  community-list: BYOIP_LEAK_COMMUNITY_LIST
                set:
                  tag: 65100{{/* tag it so we can match on the tag and use it for leaking later */}}
                  community:
                      none: {}{{/* Strip any communities the peer might have attached. */}}
                  large-community:
                    none: {}
              '11':
                action:
                  permit: {}
                match:
                  type: ipv4
                  ip-prefix-list: DPU_FROM_INSTANCE_PREFIX_LIST
                set:
                  tag: 65101{{/* tag it so we can match on the tag and use it for leaking later */}}
                  community:
                      none: {}{{/* Strip any communities the peer might have attached. */}}
                  large-community:
                    none: {}
              '65535':
                action:
                  deny: {}
          dpu_to_instance:
            rule:
              '10':
                action:
                  deny: {}
          dpu_to_traffic_intercept_gw_peer:
            rule:
              '10':
                action:
                  deny: {}
{{- if $nvueConfig.StatefulAclsEnabled }}
    system:
      reflexive-acl:
        enable: on                  
{{- end }}
    vrf:
      default:
        router:
        {{- if $nvueConfig.HasStaticAdvertisements }}
          static:
          {{- if $nvueConfig.HasSecondaryOverlayVTEP }}
            {{ $nvueConfig.SecondaryOverlayVtepIP }}/32:
              address-family: ipv4-unicast
              via:
                {{ $nvueConfig.VfInterceptBridgeIP }}:
                  type: ipv4-address
          {{- end }}
        {{- end }}
          nexthop-tracking:
            ipv4:
              resolved-via-default: on
          bgp:
            address-family:
              ipv4-unicast:
              {{- if $nvueConfig.HasStaticAdvertisements }}
                network:
                {{- if $nvueConfig.HasSecondaryOverlayVTEP }}
                  {{ $nvueConfig.SecondaryOverlayVtepIP }}/32: {}
                {{- end }}
              {{- end}}
                enable: on
                multipaths:
                  ebgp: 128
                redistribute:
                  connected:
                    enable: on
              l2vpn-evpn:
                enable: on
            enable: on
            neighbor:
{{- range $nvueConfig.RouteServers }}
              {{ . }}:
                peer-group: routeserver
                type: numbered
{{- end }}
{{- range $nvueConfig.Uplinks}}
              {{ . }}:
                peer-group: underlay
                type: unnumbered
{{- end }}
            path-selection:
              multipath:
                aspath-ignore: on
                bandwidth: ignore
            peer-group:
              routeserver:
                address-family:
                  ipv4-unicast:
                    enable: off
                  l2vpn-evpn:
                    enable: on
                    policy:
                      outbound:
                        route-map: dpu_to_evpn
                multihop-ttl: 255
                remote-as: external
                update-source: lo
              underlay:
                remote-as: external
                address-family:
                  ipv4-unicast:
                    policy:
                      outbound:
                        route-map: leak_to_underlay
{{- if eq (len $nvueConfig.RouteServers) 0 }}
                  l2vpn-evpn:
                    enable: on
                    policy:
                      outbound:
                        route-map: dpu_to_evpn
{{- end }}  
{{/* Tenant VRF LOOP START */}}
{{ range $vpc := $tenant.Vpcs }}
      {{ $vpc.VrfName }}: {{/* A VRF (VPC) needs to be defined on each DPU. This also creates an interface which introduces a max of 15 chars */}}
        evpn:
          enable: on
          vni:
            {{ if $nvueConfig.HasSiteGlobalVpcVni }}'{{$nvueConfig.SiteGlobalVpcVni}}'{{ else }}'{{ $vpc.L3VNI }}'{{ end }}: {} {{/* A VRF (VPC) needs a unique VNI to create the tenant separation */}}
        loopback:
          ip:
            address:
              {{ $vpc.VrfLoopback }}/32: {} {{/* Every VRF on each DPU requires a unique loopback address */}}
        router:
        {{- if $nvueConfig.UseAdminNetwork }}
          static:
            {{- range $vpc.HostInterfaces }}
            {{ .HostRoute }}:
              address-family: ipv4-unicast
              via:
                vlan{{ .ID }}:
                  type: interface
            {{- end }}
        {{- end }}
          bgp:
            path-selection:
              multipath:
                aspath-ignore: on
            address-family:
              ipv4-unicast:
              {{- if $nvueConfig.UseAdminNetwork }}
                network:
                  {{- range $vpc.HostInterfaces }}
                  {{ .HostRoute }}: {}
                  {{- end }}              
              {{- end }}
                enable: on
                redistribute:
                  connected:
                    enable: on
                route-export:
                  to-evpn:
                    enable: on
            enable: on
            neighbor:
  {{- range $vpc.HostInterfaces}}
    {{- if .HostIP }}
              {{ .HostIP }}:
                passive-mode: on
                peer-group: tenant
                type: numbered
    {{- end }}
  {{- end }}
  {{- if $nvueConfig.PublicPrefixInternalNextHop }}
              {{ $nvueConfig.PublicPrefixInternalNextHop }}:
                passive-mode: on
                peer-group: traffic_intercept_gw_peer
                type: numbered
  {{- end }}
            peer-group:
              traffic_intercept_gw_peer:
                address-family:
                  ipv4-unicast:
                    policy:
                      inbound:
                        route-map: dpu_from_traffic_intercept_gw_peer
                      outbound:
                        route-map: dpu_to_traffic_intercept_gw_peer
                nexthop-connected-check: off
                remote-as: external
                timers:
                  connection-retry: 10
                  hold: 9
                  keepalive: 3
                  route-advertisement: none
              tenant:
                address-family:
                  ipv4-unicast:
                    policy:
                      inbound:
                        route-map: dpu_from_instance
                      outbound:
                        route-map: dpu_to_instance
                nexthop-connected-check: off
                {{- if $nvueConfig.Tenant.HasHostASN }}
                remote-as: {{ $nvueConfig.Tenant.HostASN }}
                {{- else }}
                remote-as: external
                {{- end }}
                timers:
                  connection-retry: 10
                  hold: 9
                  keepalive: 3
                  route-advertisement: none
            route-export:
              to-evpn:
                route-target:
                  {{ $.DatacenterASN }}:{{ $vpc.L3VNI }}: {}
                {{- if $.UseCommonInternalTenantRouteTarget }}
                  {{ $.CommonInternalRouteTarget.ASN }}:{{ $.CommonInternalRouteTarget.VNI }}: {} {{/* TODO: this can now be removed or repurposed to be a site-wide common route tag if desired. */}}
                {{- end}}
                {{- range $vpc.RoutingProfile.RouteTargetsOnExports }}
                  {{ .ASN }}:{{ .VNI }}: {}
                {{- end}}
            route-import:
              from-evpn:
                route-target:
                  {{ $.DatacenterASN }}:{{ $vpc.L3VNI }}: {}
                {{- range $vpc.VpcPeerVnis }}
                  {{ $.DatacenterASN }}:{{ .Vni }}: {}
                {{- end}}
                {{- range $vpc.RoutingProfile.RouteTargetImports }}
                  {{ .ASN }}:{{ .VNI }}: {}
                {{- end}}
                {{- range $.AdditionalRouteTargetImports }}
                  {{ .ASN }}:{{ .VNI }}: {}
                {{- end}}
                  auto: {}
{{- end }}
{{/* Tenant VRF LOOP END */}}
    acl:
      dhcp_flood_prevention:
        rule: 
          '10':
            action:
              deny: {}
            hw-offload: off
            match:
              ip:
                dest-ip: 255.255.255.255
                dest-port:
                  '67': {}
                protocol: udp
                source-port:
                  '68': {}
        type: ipv4

  {{- if $nvueConfig.HasDenyPrefixes }}
      p0000_deny_prefixes_ipv4:
        type: ipv4
        rule:
    {{- range $nvueConfig.DenyPrefixes }}
          '{{ .Index }}':
            action:
              deny: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
    {{- end }}
  {{- end }}
{{/* VPC(VRF)-specific policy loop START */}}
{{ range $vpc := $tenant.Vpcs }}
  {{- if $vpc.HasVpcPeerPrefixes }}
      p0009_{{ $vpc.VrfName }}_peer_egress_from_host:
        type: ipv4
        rule:
        {{- range $vpc.VpcPeerPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
        {{- end }}
      p0009_{{ $vpc.VrfName }}_peer_ingress_to_host:
        type: ipv4
        rule:
        {{- range $vpc.VpcPeerPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                source-ip: {{ .Prefix }}
        {{- end }}
  {{- end }}
  {{- if and ($.UseVpcIsolation) ($.HasSiteFabricPrefixes) }}
      p0010_{{ $vpc.VrfName }}_isolation_ipv4:
        type: ipv4
        rule:
      {{- range $vpc.PortPrefixes }}
          '{{ .Index }}':
            action:
              permit: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
      {{- end }}
      {{- range $nvueConfig.SiteFabricPrefixes }}
          '{{ .Index }}':
            action:
              deny: {}
            match:
              ip:
                dest-ip: {{ .Prefix }}
      {{- end }}
  {{- end }}
{{- end }}
{{/* VPC(VRF)-specific policy loop END */}}
{{/* NSG-specific policy loop START */}}
 {{- range $nsg := $tenant.NetworkSecurityGroups }}
      p0005_{{ $nsg.Index }}_security_group_ipv4_host_egress: {{/* Egress from host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
        {{- range $nsg.EgressNetworkSecurityGroupRulesIpv4 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              {{- if and ($nvueConfig.StatefulAclsEnabled) ($nsg.StatefulEgress) (.CanBeStateful) }}
              conntrack:{{/* Testing showed this is not needed, but we should follow the docs */}}
                new: {}
                established: {}
              {{- end }}
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
          '65535':
            action:
              deny: {}
        type: ipv4
      p0005_{{ $nsg.Index }}_security_group_ipv6_host_egress: {{/* Egress from host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
        {{- range $nsg.EgressNetworkSecurityGroupRulesIpv6 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
          '65535':
            action:
              deny: {}
        type: ipv6
      p0005_{{ $nsg.Index }}_security_group_ipv4_host_ingress: {{/* Ingress to host. Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
        {{- range $nsg.IngressNetworkSecurityGroupRulesIpv4 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }}
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- if and ($nvueConfig.StatefulAclsEnabled) ($nsg.StatefulEgress) }}
          '65532':
            action:
              permit: {}
            match:
              ip:
                protocol: tcp
              conntrack:
                established: {}
          '65533':
            action:
              permit: {}
            match:
              ip:
                protocol: udp
              conntrack:
                established: {}
          '65534':
            action:
              permit: {}
            match:
              ip:
                protocol: icmp
              conntrack:
                established: {}
      {{- end }}
          '65535':
            action:
              deny: {}
        type: ipv4
      p0005_{{ $nsg.Index }}_security_group_ipv6_host_ingress: {{/* Ingress to host.  Ingress and Egress is defined from instance perspective, so reverse on DPU side */}}
        rule:
        {{- range $nsg.IngressNetworkSecurityGroupRulesIpv6 }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
          '65535':
            action:
              deny: {}
        type: ipv6
{{- end }}
{{/* NSG-specific policy loop END */}}
      {{- if $nvueConfig.HasIpv4EgressSecurityPolicyOverrideRules }}
      p0004_security_policy_override_ipv4_host_egress:
        type: ipv4
        rule:
        {{- range $nvueConfig.Ipv4EgressNetworkSecurityPolicyOverrideRules }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
      {{- if $nvueConfig.HasIpv6EgressSecurityPolicyOverrideRules }}
      p0004_security_policy_override_ipv6_host_egress:
        type: ipv6
        rule:
        {{- range $nvueConfig.Ipv6EgressNetworkSecurityPolicyOverrideRules }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
      {{- if $nvueConfig.HasIpv4IngressSecurityPolicyOverrideRules }}
      p0004_security_policy_override_ipv4_host_ingress:
        type: ipv4
        rule:
        {{- range $nvueConfig.Ipv4IngressNetworkSecurityPolicyOverrideRules }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }}
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end }}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
      {{- if $nvueConfig.HasIpv6IngressSecurityPolicyOverrideRules }}
      p0004_security_policy_override_ipv6_host_ingress:
        type: ipv6
        rule:
        {{- range $nvueConfig.Ipv6IngressNetworkSecurityPolicyOverrideRules }}
          '{{ .Priority }}':
            action:
              {{ .Action }}: {}
            match:
              ip:
                dest-ip: {{ .DstPrefix }}
                {{- if .HasDstPort }}
                dest-port:
                  '{{ .DstPort }}': {}
                {{- end }} 
                {{- if not .CanMatchAnyProtocol }} 
                protocol: {{ .Protocol }}
                {{- end}}
                source-ip: {{ .SrcPrefix }} 
                {{- if .HasSrcPort }}
                source-port:
                  '{{ .SrcPort }}': {}
                {{- end }} 
        {{- end }}
      {{- end }}
